/**

******************************************************************************

* @file : main.c

* @author : Auto-generated by STM32CubeIDE

* @brief : Main program body

******************************************************************************

* @attention

*

* Copyright (c) 2025 STMicroelectronics.

* All rights reserved.

*

* This software is licensed under terms that can be found in the LICENSE file

* in the root directory of this software component.

* If no LICENSE file comes with this software, it is provided AS-IS.

*

******************************************************************************

*/



#include <stdint.h>

#include "stm32f411xe.h"



#if !defined(__SOFT_FP__) && defined(__ARM_FP)

#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."

#endif
volatile static uint32_t time[41],count,bits[40];
 volatile static uint32_t trise, tfall,have_rise_timestamp;

static void tim5_init_1us(void)

{

RCC->APB1ENR |= RCC_APB1ENR_TIM5EN;

TIM5->CR1 = 0;

TIM5->PSC = 15; // 16MHz/16 = 1MHz => 1us tick

TIM5->EGR = TIM_EGR_UG;

TIM5->SR = 0;

}

static void tim2_init_cnt(void)
{
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
	TIM2->CCMR1&=~0X03;
	    TIM2->CCMR1|=0X01;//CC1S: Capture/Compare 1 selection
		TIM2->CNT=0;
		TIM2->CCER=0X0B;//falling and raising edge detection, capture enabled
		TIM2->DIER=0x02;// enabled IRQ for edge
		TIM2->PSC = 15;
		TIM2->EGR = TIM_EGR_UG;
		TIM2->SR = 0;
		TIM2->CR1|=0X01;


}



static void delay_us(uint32_t us)

{

TIM5->CR1 = TIM_CR1_OPM;

TIM5->ARR = us - 1U;

TIM5->CNT = 0U;

TIM5->EGR = TIM_EGR_UG;

TIM5->CR1 |= TIM_CR1_CEN;

TIM5->SR = 0U;

while((TIM5->SR & TIM_SR_UIF) == 0U) { }

TIM5->SR = 0U;

}



static void delay_ms(uint32_t ms)

{

while(ms--) delay_us(1000);

}

void TIM2_IRQHandler()

{


	if((TIM2->SR&(1<<1)))
	{
		if(GPIOA->IDR&(0X01))
		{
			trise= TIM2->CCR1;
			have_rise_timestamp=1;

		}
		else
		{
			tfall=TIM2->CCR1;
			if(count<41 &&have_rise_timestamp)
			time[count++]=tfall-trise;
			have_rise_timestamp=0;

		}


	}
	TIM2->SR &= ~(0x1UL << (1U));
	//NVIC_ClearPendingIRQ(TIM2_IRQn);



}



void get_bits()
{
	for(int i=1;i<41;i++)
	{
		if(time[i]<40U)
		{
			bits[i-1]=0;
		}
		else if (time[i]>=40U)
		{
					bits[i-1]=1;
		}
		else
		{
			bits[i-1]=0;
		}
	}

}
uint16_t bits_to_data(int index)
{
	uint16_t sum=0;
	int i,bitpos=7;
	for(i=index;i<(index+8);i++)
	{
		sum|=(bits[i]<<(bitpos--));


	}
	return sum;


}


int main(void)

{


RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;



// PA0 output open-drain

GPIOA->MODER &= ~3U;

GPIOA->MODER |= 1U;

GPIOA->OTYPER |= 1U;

tim5_init_1us();// LOW 2ms
tim2_init_cnt();

GPIOA->BSRR = (1U << 16);

delay_ms(1);
// HIGH 30us (release while still output)
GPIOA->BSRR = (1U << 0); // in open-drain this "releases"

delay_us(30);



// switch to AF (fully release)
GPIOA->MODER &= ~3U;
GPIOA->MODER |= 2U;
GPIOA->AFR[0]&=~0x0F;
GPIOA->AFR[0]|=0x01;

GPIOA->PUPDR &= ~3U;

GPIOA->PUPDR |= 1U; // optional internal pull-up
TIM2->SR = 0;
NVIC_ClearPendingIRQ(TIM2_IRQn);

NVIC_EnableIRQ(TIM2_IRQn);

while(count>=41);
get_bits();
uint16_t humd=(bits_to_data(0)<<8);
		humd=humd|bits_to_data(8);
uint16_t temp=(bits_to_data(16)<<8);
		temp=temp|bits_to_data(24);
uint8_t  chksum=bits_to_data(32);

	for(;;);












}



